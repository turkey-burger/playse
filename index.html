<<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>playse</title>

  <!-- Google Font: Oxygen Mono -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oxygen+Mono&display=swap" rel="stylesheet">

  <!-- Custom logo font placeholder (self-host later) -->
  <!--
  <style>
    @font-face {
      font-family: 'PlayseLogo';
      src: url('./fonts/playse-logo.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }
  </style>
  -->

  <style>
    :root {
      --bg: #000;
      --fg: #fff;
      --muted: rgba(255,255,255,0.6);
      --border: rgba(255,255,255,0.9);
      --toast-bg: rgba(255,255,255,0.12);
      --toast-border: rgba(255,255,255,0.25);
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: 'Oxygen Mono', monospace;
    }

    .app {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .frame {
      width: 100%;
      max-width: 480px;
      text-align: center;
    }

    /* LOGO */
    .logo {
      font-size: 28px;
      letter-spacing: 0.02em;
      margin-bottom: 40px;
      /* font-family: 'PlayseLogo', 'Oxygen Mono', monospace; */
    }

    /* PLAY BUTTON */
    .play-btn {
      appearance: none;
      background: none;
      border: 2px solid var(--border);
      color: var(--fg);
      width: 120px;
      height: 120px;
      border-radius: 999px;
      font-size: 16px;
      cursor: pointer;
    }

    .play-btn:active {
      transform: scale(0.98);
    }

    /* TRACK INFO */
    .track {
      margin-top: 32px;
      line-height: 1.6;
    }

    .track .title {
      font-size: 14px;
    }

    .track .artist {
      font-size: 13px;
      color: var(--muted);
    }

    /* ADD TO LIBRARY */
    .actions {
      margin-top: 28px;
      display: flex;
      gap: 16px;
      justify-content: center;
    }

    .actions a {
      color: var(--fg);
      text-decoration: none;
      border-bottom: 1px solid var(--fg);
      font-size: 12px;
    }

    .actions a.disabled {
      opacity: 0.35;
      border-bottom-color: transparent;
      cursor: not-allowed;
    }

    /* STATES */
    .hidden { display: none; }

    /* LOADING */
    .loading {
      font-size: 12px;
      color: var(--muted);
      margin-top: 24px;
    }

    /* TOAST */
    .toast {
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      max-width: min(520px, calc(100vw - 24px));
      padding: 12px 14px;
      border: 1px solid var(--toast-border);
      background: var(--toast-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--fg);
      font-size: 12px;
      line-height: 1.4;
      border-radius: 999px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      text-align: center;
    }

    .toast.show {
      opacity: 1;
    }

    @media (max-width: 480px) {
      .logo { font-size: 24px; }
      .play-btn { width: 96px; height: 96px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="frame">

      <!-- STATE: LANDING -->
      <div id="state-landing">
        <div class="logo">playse</div>
        <button class="play-btn" id="playBtn">Play</button>
      </div>

      <!-- STATE: LOADING -->
      <div id="state-loading" class="hidden">
        <div class="logo">playse</div>
        <div class="loading">loading…</div>
      </div>

      <!-- STATE: PLAYER -->
      <div id="state-player" class="hidden">
        <div class="logo">playse</div>
        <button class="play-btn" id="toggleBtn">Pause</button>

        <div class="track">
          <div class="title" id="trackTitle">—</div>
          <div class="artist" id="trackArtist">—</div>
        </div>

        <div class="actions">
          <a id="spotifyLink" href="#" target="_blank" rel="noopener">Spotify</a>
          <a id="appleLink" href="#" target="_blank" rel="noopener">Apple Music</a>
        </div>
      </div>

      <audio id="audio" preload="metadata"></audio>
    </div>
  </div>

  <div class="toast" id="toast" aria-live="polite" aria-atomic="true"></div>

  <script>
    // ----------------------------
    // CONFIG
    // ----------------------------
    // Add new sections by appending here. Keep audio + tracklist paired.
    // Tracklist timestamps are relative to EACH file (start at 00:00:00).
    const sections = [
      { audio: 'playse_1.mp3', tracklist: 'playse_1_tracklist.csv' },
      { audio: 'playse_2.mp3', tracklist: 'playse_2_tracklist.csv' },
      { audio: 'playse_3.mp3', tracklist: 'playse_3_tracklist.csv' },
    ];

    const NOT_AVAILABLE_MSG = "Sorry, this song isn't available on the selected streaming service";

    // ----------------------------
    // DOM
    // ----------------------------
    const audio = document.getElementById('audio');

    const landing = document.getElementById('state-landing');
    const loading = document.getElementById('state-loading');
    const player = document.getElementById('state-player');

    const playBtn = document.getElementById('playBtn');
    const toggleBtn = document.getElementById('toggleBtn');

    const trackTitle = document.getElementById('trackTitle');
    const trackArtist = document.getElementById('trackArtist');
    const spotifyLink = document.getElementById('spotifyLink');
    const appleLink = document.getElementById('appleLink');

    const toast = document.getElementById('toast');

    // ----------------------------
    // STATE
    // ----------------------------
    let started = false;
    let currentSectionIndex = 0;
    let tracklistsBySection = new Map(); // index -> array of tracks
    let currentTrackIndex = -1;
    let toastTimer = null;

    // ----------------------------
    // UI helpers
    // ----------------------------
    function show(el) {
      landing.classList.add('hidden');
      loading.classList.add('hidden');
      player.classList.add('hidden');
      el.classList.remove('hidden');
    }

    function showToast(message) {
      toast.textContent = message;
      toast.classList.add('show');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        toast.classList.remove('show');
      }, 2400);
    }

    function setLink(el, url) {
      const has = !!(url && String(url).trim());
      if (has) {
        el.href = url;
        el.classList.remove('disabled');
        el.setAttribute('aria-disabled', 'false');
      } else {
        el.href = '#';
        el.classList.add('disabled');
        el.setAttribute('aria-disabled', 'true');
      }
    }

    function updateTrackUI(track) {
      if (!track) {
        trackTitle.textContent = '—';
        trackArtist.textContent = '—';
        setLink(spotifyLink, '');
        setLink(appleLink, '');
        return;
      }

      trackTitle.textContent = track.title || '—';
      trackArtist.textContent = track.artist || '—';
      setLink(spotifyLink, track.spotify_url);
      setLink(appleLink, track.apple_music_url);
    }

    // ----------------------------
    // CSV parsing
    // ----------------------------
    function timeToSeconds(hms) {
      const s = String(hms || '').trim();
      if (!s) return 0;
      const parts = s.split(':').map(p => p.trim());
      if (parts.length === 2) {
        const mm = Number(parts[0]);
        const ss = Number(parts[1]);
        return (mm * 60) + ss;
      }
      if (parts.length === 3) {
        const hh = Number(parts[0]);
        const mm = Number(parts[1]);
        const ss = Number(parts[2]);
        return (hh * 3600) + (mm * 60) + ss;
      }
      return 0;
    }

    function detectDelimiter(text) {
      // Look at the first non-empty line to guess delimiter.
      const lines = String(text || '').split(/?/)
      
.filter(l => l.trim().length);
      const head = lines[0] || '';
      const comma = (head.match(/,/g) || []).length;
      const semi = (head.match(/;/g) || []).length;
      const tab = (head.match(/	/g) || []).length;
      // Prefer the most frequent.
      if (semi > comma && semi >= tab) return ';';
      if (tab > comma && tab > semi) return '	';
      return ',';
    }

    function parseDelimited(text, delimiter) {
      // Minimal CSV/DSV parser that supports quoted fields.
      const rows = [];
      let row = [];
      let cell = '';
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (inQuotes) {
          if (ch === '"' && next === '"') {
            cell += '"';
            i++;
          } else if (ch === '"') {
            inQuotes = false;
          } else {
            cell += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === delimiter) {
            row.push(cell);
            cell = '';
          } else if (ch === '') 
          {
            row.push(cell);
            rows.push(row);
            row = [];
            cell = '';
          } else if (ch === '') {
            // ignore
          } else {
            cell += ch;
          }
        }
      }

      if (cell.length || row.length) {
        row.push(cell);
        rows.push(row);
      }

      return rows;
    }

    function parseCSV(text) {
      const delimiter = detectDelimiter(text);
      return parseDelimited(text, delimiter);
    }

    async function loadTracklistForSection(index) {
      if (tracklistsBySection.has(index)) return tracklistsBySection.get(index);

      const url = sections[index].tracklist;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Failed to load tracklist: ${url}`);
      const text = await res.text();

      const rows = parseCSV(text);
      if (!rows.length) {
        tracklistsBySection.set(index, []);
        return [];
      }

      // Normalize header names (supports your earlier CSV shape)
      const header = rows[0].map(h => String(h || '').trim().toLowerCase());

      const idxTime = header.findIndex(h => ['start_time','time','timestamp'].includes(h));
      const idxTitle = header.findIndex(h => ['title','track title','track','song','song title'].includes(h));
      const idxArtist = header.findIndex(h => ['artist','artist name','artist(s)','artists'].includes(h));
      const idxSpotify = header.findIndex(h => ['spotify_url','spotify','spotify url','spotify link','spotify_uri'].includes(h));
      const idxApple = header.findIndex(h => ['apple_music_url','apple','apple url','apple music','apple_music','apple link'].includes(h));

      // Fallback to common column order if headers don't match.
      const colTime = (idxTime >= 0) ? idxTime : 0;
      const colTitle = (idxTitle >= 0) ? idxTitle : 1;
      const colArtist = (idxArtist >= 0) ? idxArtist : 2;
      const colSpotify = (idxSpotify >= 0) ? idxSpotify : 3;
      const colApple = (idxApple >= 0) ? idxApple : 4;

      const tracks = [];
      for (let r = 1; r < rows.length; r++) {
        const cols = rows[r];
        if (!cols || !cols.length) continue;

        const start = timeToSeconds(cols[colTime] ?? cols[0]);
        const title = String(cols[colTitle] ?? '').trim();
        const artist = String(cols[colArtist] ?? '').trim();
        const spotify_url = String(cols[colSpotify] ?? '').trim();
        const apple_music_url = String(cols[colApple] ?? '').trim();

        // Ignore empty rows
        if (!title && !artist) continue;

        tracks.push({
          start,
          title,
          artist,
          spotify_url,
          apple_music_url,
        });
      }

      // Ensure sorted
      tracks.sort((a, b) => a.start - b.start);

      tracklistsBySection.set(index, tracks);
      return tracks;
    }

    function findTrackIndex(tracks, seconds) {
      // tracks sorted by start
      if (!tracks || !tracks.length) return -1;
      // quick bounds
      if (seconds < tracks[0].start) return 0;
      let lo = 0;
      let hi = tracks.length - 1;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const a = tracks[mid];
        const b = tracks[mid + 1];
        if (seconds >= a.start && (!b || seconds < b.start)) return mid;
        if (seconds < a.start) hi = mid - 1;
        else lo = mid + 1;
      }
      return tracks.length - 1;
    }

    // ----------------------------
    // Playback
    // ----------------------------
    async function setSection(index) {
      currentSectionIndex = index;
      currentTrackIndex = -1;

      // Load tracklist in parallel with audio metadata
      const tracklistPromise = loadTracklistForSection(index).catch(err => {
        console.error(err);
        return [];
      });

      audio.src = sections[index].audio;
      audio.load();

      const tracks = await tracklistPromise;
      // Update UI immediately based on 0:00 in this section
      const initialIdx = findTrackIndex(tracks, 0);
      currentTrackIndex = initialIdx;
      updateTrackUI(tracks[initialIdx]);
    }

    async function startRandom() {
      show(loading);

      // Choose a random section (uniform). Because sections are ~1 hour, this is fine.
      // If you later have varied lengths, we can weight by duration.
      const idx = Math.floor(Math.random() * sections.length);
      await setSection(idx);

      // Must begin playback on a user gesture, then seek once metadata is known.
      await audio.play();

      // Wait until duration is known (some browsers need a tick)
      if (!Number.isFinite(audio.duration) || audio.duration <= 0) {
        await new Promise(resolve => {
          const onMeta = () => {
            audio.removeEventListener('loadedmetadata', onMeta);
            resolve();
          };
          audio.addEventListener('loadedmetadata', onMeta);
        });
      }

      // Safety buffer so we don't land too close to the end.
      const buffer = 3;
      const max = Math.max(0, audio.duration - buffer);
      audio.currentTime = Math.random() * max;

      started = true;
      // UI will switch to player on the 'play' event.
    }

    async function playFromCurrentState() {
      show(loading);
      await audio.play();
    }

    async function goToNextSectionAndPlay() {
      const next = (currentSectionIndex + 1) % sections.length;
      await setSection(next);
      await audio.play();
      audio.currentTime = 0;
    }

    // ----------------------------
    // Event wiring
    // ----------------------------
    playBtn.addEventListener('click', async () => {
      try {
        if (!started) {
          await startRandom();
        } else {
          await playFromCurrentState();
        }
      } catch (err) {
        console.error(err);
        show(landing);
        showToast('Playback failed. Try again.');
      }
    });

    toggleBtn.addEventListener('click', async () => {
      try {
        if (audio.paused) {
          show(loading);
          await audio.play();
        } else {
          audio.pause();
        }
      } catch (err) {
        console.error(err);
        showToast('Playback failed. Try again.');
      }
    });

    audio.addEventListener('play', () => {
      toggleBtn.textContent = 'Pause';
      show(player);
    });

    audio.addEventListener('pause', () => {
      toggleBtn.textContent = 'Play';
      // Remain in player state
    });

    audio.addEventListener('ended', async () => {
      // Seamless chronological playback
      try {
        await goToNextSectionAndPlay();
      } catch (err) {
        console.error(err);
        showToast('Could not load the next section.');
      }
    });

    audio.addEventListener('timeupdate', () => {
      const tracks = tracklistsBySection.get(currentSectionIndex) || [];
      if (!tracks.length) return;

      const t = audio.currentTime;
      const idx = findTrackIndex(tracks, t);
      if (idx !== currentTrackIndex) {
        currentTrackIndex = idx;
        updateTrackUI(tracks[idx]);
      }
    });

    // Streaming link behavior: if missing, show message instead of navigating.
    function attachUnavailableHandler(el) {
      el.addEventListener('click', (e) => {
        if (el.classList.contains('disabled') || el.getAttribute('aria-disabled') === 'true' || el.getAttribute('href') === '#') {
          e.preventDefault();
          showToast(NOT_AVAILABLE_MSG);
        }
      });
    }

    attachUnavailableHandler(spotifyLink);
    attachUnavailableHandler(appleLink);

    // Initial state
    show(landing);
    updateTrackUI(null);
  </script>
</body>
</html>
